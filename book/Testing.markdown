Testing
=======

Using Rack::Test
----------------

Testing is an integral part of software development. In this section we will
look into testing the Sinatra application itself. For unit testing your models
or other classes, please consult the documentation of frameworks used
(including your test framework itself). Sinatra itself uses [Contest][ct] for
testing, but feel free to use any framework you like.

Bryan Helmkamp's [Rack::Test][rt] offers tools for mocking Rack request,
sending those to your application and inspecting the response all wrapped in a
small DSL.

### Firing Requests

You import the DSL by including `Rack::Test::Methods` into your test
framework. It is even usable without a framework and for other tasks besides
testing.

Imagine you have an application like this:

    # myapp.rb
    require 'sinatra'
    
    get '/' do
      "Welcome to my page!"
    end
    
    post '/' do
      "Hello #{params[:name]}!"
    end

You have to define an `app` method pointing to your application class (which is
`Sinatra::Application` per default):

    require 'myapp.rb'
    require 'test/unit'
    require 'rack/test'

    class MyAppTest < Test::Unit::TestCase
      include Rack::Test::Methods

      def app
        Sinatra::Application
      end
      
      def test_my_default
        get '/'
        assert last_response.ok?
        assert_equal 'Welcome to my page!', last_response.body
      end

      def test_with_params
        post '/', :name => 'Frank'
        assert_equal 'Hello Frank!', last_response.body
      end
    end

### Modifying `env`

While parameters can be send via the second argument of a get/post/put/delete
call (see the post example above), the env hash (and thereby the HTTP headers)
can be modified with a third argument:

    get '/foo', {}, 'HTTP_USER_AGENT' => 'Songbird 1.0'

This also allows passing internal `env` settings:

    get '/foo', {}, 'rack.session' => { 'user_id' => 20 }

### Cookies

For example, add the following to your app to test against:

    "Hello #{request.cookies['foo']}!"

Use `set_cookie` for setting and removing cookies, and the access them in your response:

    set_cookie 'foo=bar'
    get '/'
    assert_equal 'Hello bar!', last_response.body 

### Asserting Expectations About The Response

Once a request method has been invoked, the following attributes are
available for making assertions:

 * `app` - The Sinatra application class that handled the mock request.

 * `last_request` - The
 [`Rack::MockRequest`](http://rdoc.info/gems/rack/1.2.1/frames/Rack/MockRequest)
 used to generate the request.

 * `last_response` - A
 [`Rack::MockResponse`](http://rdoc.info/gems/rack/1.2.1/frames/Rack/MockResponse)
 instance with information on the response generated by the application.

Assertions are typically made against the `last_response` object.
Consider the following examples:

    def test_it_says_hello_world
      get '/'
      assert last_response.ok?
      assert_equal 'Hello World'.length.to_s, last_response.headers['Content-Length']
      assert_equal 'Hello World', last_response.body
    end

### Optional Test Setup

The `Rack::Test` mock request methods send requests to the return value of
a method named `app`.

If you're testing a modular application that has multiple `Sinatra::Base`
subclasses, simply set the `app` method to return your particular class.

      def app
        MySinatraApp
      end

If you're using a classic style Sinatra application, then you need to return an
instance of `Sinatra::Application`.

      def app
        Sinatra::Application
      end

### Making `Rack::Test` available to all test cases

If you'd like the `Rack::Test` methods to be available to all test cases
without having to include it each time, you can include the `Rack::Test`
module in the `Test::Unit::TestCase` class:

    require 'test/unit'
    require 'rack/test'

    class Test::Unit::TestCase
      include Rack::Test::Methods
    end

Now all `TestCase` subclasses will automatically have `Rack::Test`
available to them.

### Usage with Minitest

Since Ruby 1.9, [Minitest][mt] is shipped with the standard library. If you
want to use it on 1.8, it is still installable via Rubygems.

After installing Minitest, setting it up works similar to `Test::Unit`:

    ENV['RACK_ENV'] = 'test'
    require 'minitest/unit'
    require 'rack/test'
    require 'my-app'

    module TestMixin
      include Rack::Test::Methods
      Minitest::Unit.send(:include, self)
      def app() Sinatra::Application end
    end

### Mocks and Benchmarks with Minitest

TODO
...
TODO

### Usage with Test::Unit, Test::Spec or Contest

One of the advantages of using
[Test::Unit](http://rdoc.info/gems/test-unit/2.1.2/frames) is that it already
ships with Ruby **1.8.7** and you can skip the installation part in some cases.

Set up rack-test by including `Rack::Test::Methods` into your test class and
defining `app`:

    ENV['RACK_ENV'] = 'test'
    require 'test/unit'
    require 'rack/test'
    require 'myapp'
    
    class HomepageTest < Test::Unit::TestCase
      include Rack::Test:Methods
      def app() Sinatra::Application end
      
      def test_homepage
        get '/'
        assert last_response.ok?
      end
    end

If you have multiple test files, you could create a test helper file and do
all the setup in there:

    # test/test_helper.rb
    ENV['RACK_ENV'] = 'test'
    require 'test/unit'
    require 'rack/test'
    require 'my-app'
    
    module TestMixin
      include Rack::Test::Methods
      Test::Unit::TestCase.send(:include, self)
      def app() Sinatra::Application end
    end

In your test files you only have to require that helper:

    # test/homepage_test.rb
    # if you only target Ruby >= 1.9, you could use require_relative
    require File.expand_path('../test_helper', __FILE__)
    
    class HomepageTest < Test::Unit::TestCase
      def test_homepage
        get '/'
        assert last_response.ok?
      end
    end

Since [Contest][ct] and [Test::Spec][ts] are both extensions for Test::Unit,
all you have to do is install them and add a `require 'contest'` or `require
'test/spec'` to your test helper.

### Test::Unit with Shoulda and Factory Girl

**Shoulda**

**Factory Girl**

### Mocking for Test::Unit

**Mocha**

**Flexmock**

**Double Ruby**

### Usage with RSpec 2.x

TODO
...
TODO

### Usage with RSpec 1.x

[RSpec][rs] is the main competitor to Test::Unit. It is feature rich and
pleasant to read, but to heavy for some. Therefore most other frameworks
mentioned here (except Minitest, Test::Unit and Cucumber) try to adopt its API
without its inner complexity. The 1.x version of RSpec is still widely spread
and 2.x still lacks major adoption.

In your spec file or your spec helper, you can setup `Rack::Test` like this:

    # spec/spec_helper.rb
    ENV['RACK_ENV'] = 'test'
    require 'test/unit'
    require 'rack/test'
    require 'my-app'
    
    module TestMixin
      include Rack::Test::Methods
      def app() Sinatra::Application end
    end
    
    Spec::Runner.configure { |c| c.include TestMixin }

And use it in your specs:

    require File.expand_path('../spec_helper', __FILE__)
    
    describe "My Sinatra Application" do
      it "should allow accessing the home page" do
        get '/'
        last_response.should be_ok
      end
    end

### Usage with Bacon

After installing [Bacon][bc], setting it up works similar to `Test::Unit`:

    ENV['RACK_ENV'] = 'test'
    require 'bacon'
    require 'rack/test'
    require 'my-app'

    module TestMixin
      include Rack::Test::Methods
      Bacon::Context.send(:include, self)
      def app() Sinatra::Application end
    end

### Usage with MSpec

After installing [MSpec][ms], you set it up like this:

    ENV['RACK_ENV'] = 'test'
    require 'mspec'
    require 'rack/test'
    require 'my-app'
    
    include Rack::Test::Methods
    def app() Sinatra::Application end

### Usage with Protest

After installing [Protest][pt], setting it up works similar to `Test::Unit`:

    ENV['RACK_ENV'] = 'test'
    require 'protest'
    require 'rack/test'
    require 'my-app'

    module TestMixin
      include Rack::Test::Methods
      Protest::TestCase.send(:include, self)
      def app() Sinatra::Application end
    end

Using Steak
-----------

TODO
...
TODO

Using Capybara
--------------

### Test::Unit

### Cucumber

Using Sinatra::TestHelper
-------------------------

### Making sure you don't break Sinatra

[ct]: http://github.com/citrusbyte/contest#readme "Contest"
[rt]: http://github.com/brynary/rack-test/#readme "Rack::Test"
[tu]: http://ruby-doc.org/stdlib/libdoc/test/unit/rdoc/ "Test::Unit"
[ts]: http://test-spec.rubyforge.org/test-spec/ "Test::Spec"
[rs]: http://rspec.info/ "RSpec"
[bc]: http://github.com/chneukirchen/bacon#readme "Bacon"
[mt]: http://github.com/seattlerb/minitest#readme "Minitest"
[ms]: http://rubyspec.org/projects/show/mspec "MSpec"
[pt]: http://matflores.github.com/protest/ "Protest"
