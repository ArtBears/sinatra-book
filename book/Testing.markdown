Testing
=======

Using Rack::Test
----------------

Testing is an integral part of software development. In this section we will
look into testing the Sinatra application itself. For unit testing your models
or other classes, please consult the documentation of frameworks used
(including your test framework itself). Sinatra itself uses [Contest][ct] for
testing, but feel free to use any framework you like.

Bryan Helmkamp's [Rack::Test](https://github.com/brynary/rack-test)
offers tools for mocking Rack request, sending those to your application and
inspecting the response all wrapped in a small DSL.

### Firing Requests

You import the DSL by including `Rack::Test::Methods` into your test
framework. It is even usable without a framework and for other tasks besides
testing.

Imagine you have an application like this:

    # myapp.rb
    require 'sinatra'
    
    get '/' do
      "Welcome to my page!"
    end
    
    post '/' do
      "Hello #{params[:name]}!"
    end

You have to define an `app` method pointing to your application class (which is
`Sinatra::Application` per default):

    begin 
      # try to use require_relative first
      # this only works for 1.9
      require_relative 'my-app.rb'
    rescue NameError
      # oops, must be using 1.8
      # no problem, this will load it then
      require File.expand_path('my-app.rb', __FILE__)
    end
    
    require 'test/unit'
    require 'rack/test'

    class MyAppTest < Test::Unit::TestCase
      include Rack::Test::Methods

      def app
        Sinatra::Application
      end
      
      def test_my_default
        get '/'
        assert last_response.ok?
        assert_equal 'Welcome to my page!', last_response.body
      end

      def test_with_params
        post '/', :name => 'Frank'
        assert_equal 'Hello Frank!', last_response.body
      end
    end

### Modifying `env`

While parameters can be send via the second argument of a get/post/put/delete
call (see the post example above), the env hash (and thereby the HTTP headers)
can be modified with a third argument:

    get '/foo', {}, 'HTTP_USER_AGENT' => 'Songbird 1.0'

This also allows passing internal `env` settings:

    get '/foo', {}, 'rack.session' => { 'user_id' => 20 }

### Cookies

For example, add the following to your app to test against:

    "Hello #{request.cookies['foo']}!"

Use `set_cookie` for setting and removing cookies, and the access them in your response:

    set_cookie 'foo=bar'
    get '/'
    assert_equal 'Hello bar!', last_response.body 

### Asserting Expectations About The Response

Once a request method has been invoked, the following attributes are
available for making assertions:

 * `app` - The Sinatra application class that handled the mock request.

 * `last_request` - The
 [`Rack::MockRequest`](http://rdoc.info/gems/rack/1.2.1/frames/Rack/MockRequest)
 used to generate the request.

 * `last_response` - A
 [`Rack::MockResponse`](http://rdoc.info/gems/rack/1.2.1/frames/Rack/MockResponse)
 instance with information on the response generated by the application.

Assertions are typically made against the `last_response` object.
Consider the following examples:

    def test_it_says_hello_world
      get '/'
      assert last_response.ok?
      assert_equal 'Hello World'.length.to_s, last_response.headers['Content-Length']
      assert_equal 'Hello World', last_response.body
    end

### Optional Test Setup

The `Rack::Test` mock request methods send requests to the return value of
a method named `app`.

If you're testing a modular application that has multiple `Sinatra::Base`
subclasses, simply set the `app` method to return your particular class.

      def app
        MySinatraApp
      end

If you're using a classic style Sinatra application, then you need to return an
instance of `Sinatra::Application`.

      def app
        Sinatra::Application
      end

### Making `Rack::Test` available to all test cases

If you'd like the `Rack::Test` methods to be available to all test cases
without having to include it each time, you can include the `Rack::Test`
module in the `Test::Unit::TestCase` class:

    require 'test/unit'
    require 'rack/test'

    class Test::Unit::TestCase
      include Rack::Test::Methods
    end

Now all `TestCase` subclasses will automatically have `Rack::Test`
available to them.

### Usage with Minitest

Since Ruby 1.9, [Minitest](http://rubydoc.info/gems/minitest/2.0.1/frames) is
shipped with the standard library. If you want to use it on 1.8, it is still
installable via Rubygems.

After installing Minitest, setting it up works similar to `Test::Unit`:

If you have multiple test files, you could create a test helper file and do
all the setup in there:

    # test_helper.rb
    ENV['RACK_ENV'] = 'test'
    require 'minitest/autorun'
    require 'rack/test'
    
    begin
      require_relative 'my-app'
    rescue NameError 
      require File.expand_path('my-app', __FILE__)
    end
  
In your test files you only have to require that helper:

    # test.rb
    begin 
      require_relative 'test_helper'
    rescue NameError
      require File.expand_path('test_helper', __FILE__)
    end

    class MyTest < MiniTest::Unit::TestCase
      
      include Rack::Test::Methods

      def app() Sinatra::Application end
    
      def test_hello_world
        get '/'
        assert last_response.ok?
        assert_equal "Hello, World!", last_respones.body
      end
    end

### Specs and Benchmarks with Minitest

**Specs**

    begin 
      require_relative 'test_helper'
    rescue NameError
      require File.expand_path('test_helper', __FILE__)
    end

    include Rack::Test::Methods

    def app() Sinatra::Application end

    describe "my example app" do
      it "should successfully return a greeting" do
        get '/' 
        assert_equal 'Welcome to my page!', last_response.body 
      end
    end

**Benchmarks**

    begin 
      require_relative 'test_helper'
    rescue NameError
      require File.expand_path('test_helper', __FILE__)
    end
    
    require 'minitest/benchmark'

    include Rack::Test::Methods
    def app() Sinatra::Application end

    describe "my example app" do
      bench_range { bench_exp 1, 10_000 } 
      bench_performance_linear "welcome message", 0.9999 do |n|
        n.times do
          get '/'
          assert_equal 'Welcome to my page!', last_response.body 
        end 
      end
    end

**MiniTest Resources**

*   [Source on github](https://github.com/seattlerb/minitest)
*   [Documentation](http://rdoc.info/gems/minitest/2.0.2/frames)
*   [Official Blog Archive](http://blog.zenspider.com/minitest/) 
*   [1.9.2 Stdlib Documentation](http://rdoc.info/stdlib/minitest/1.9.2/frames)
*   [Bootspring MiniTest Blog Post](http://www.bootspring.com/2010/09/22/minitest-rubys-test-framework/)

### Usage with Test::Unit, Test::Spec or Contest

One of the advantages of using
[Test::Unit](http://rdoc.info/gems/test-unit/2.1.2/frames) is that it already
ships with Ruby **1.8.7** and you can skip the installation part in some cases.

Set up rack-test by including `Rack::Test::Methods` into your test class and
defining `app`:

    ENV['RACK_ENV'] = 'test'
    require 'test/unit'
    require 'rack/test'
    
    begin 
      require_relative 'my-app.rb'
    rescue NameError
      require File.expand_path('my-app.rb', __FILE__)
    end
    
    class HomepageTest < Test::Unit::TestCase
      include Rack::Test:Methods
      def app() Sinatra::Application end
      
      def test_homepage
        get '/'
        assert last_response.ok?
      end
    end

Since [Contest][ct] and [Test::Spec][ts] are both extensions for Test::Unit,
all you have to do is install them and add a `require 'contest'` or `require
'test/spec'` to your test helper.

**Shoulda**

    begin 
      require_relative 'test_helper'
    rescue NameError
      require File.expand_path('test_helper', __FILE__)
    end

    class ExampleUnitTest < Test::Unit::TestCase

      include Rack::Test::Methods

      def app() Sinatra::Application end

      context "view my page" do
        setup do
          get '/'
        end
      
        should "greet the visitor" do 
          assert last_response.ok? 
          assert_equal 'Welcome to my page!', last_response.body
        end
      
      end
    end  


### Usage with RSpec 2.x

**spec_helper**

    require 'rack/test'

    begin 
      require_relative '../my-app.rb'
    rescue NameError
      require File.expand_path('../my-app.rb', __FILE__)
    end

    module RSpecMixin
      include Rack::Test::Methods
      def app() Sinatra::Application end
    end

    RSpec.configure { |c| c.include RSpecMixin }

**Shared Example Groups**

[Shared Example Groups](http://relishapp.com/rspec/rspec-core/v/2-3/dir/example-groups/shared-example-group)

    begin 
      require_relative 'spec_helper'
    rescue NameError
      require File.expand_path('spec_helper', __FILE__)
    end

    shared_examples_for "my example app" do
      before(:each) do
        @expected = 'Frank'
      end
      it "should return a welcome greeting" do
        post '/', :name => @expected 
        last_response.body.should == "Hello #{@expected}!"
      end
    end

    describe "my session handler" do
      it_behaves_like "my example app"

      it "should return the name parameter from a session" do
        get '/session', {}, 'rack.session' => { 'name' => @expected }
        last_response.body.should == "Hello #{@expected}!" 
      end
    end

**RSpec 2.x Resources**

*   [RSpec 2.x Docs](http://relishapp.com/rspec)
*   [Source on github](https://github.com/rspec/rspec)
*   [Resources for RSpec 2.x developers/contributors](https://github.com/rspec/rspec-dev)

### Usage with RSpec 1.x

[RSpec][rs] is the main competitor to Test::Unit. It is feature rich and
pleasant to read, but to heavy for some. Therefore most other frameworks
mentioned here (except Minitest, Test::Unit and Cucumber) try to adopt its API
without its inner complexity. The 1.x version of RSpec is still widely spread
and 2.x still lacks major adoption.

In your spec file or your spec helper, you can setup `Rack::Test` like this:

    # spec/spec_helper.rb
    ENV['RACK_ENV'] = 'test'
    require 'test/unit'
    require 'rack/test'
    
    begin 
      require_relative 'my-app'
    rescue NameError
      require File.expand_path('my-app', __FILE__)
    end

    module TestMixin
      include Rack::Test::Methods
      def app() Sinatra::Application end
    end
    
    Spec::Runner.configure { |c| c.include TestMixin }

And use it in your specs:

    begin 
      require_relative '../spec_helper'
    rescue NameError
      require File.expand_path('../spec_helper', __FILE__)
    end
    
    describe "My Sinatra Application" do
      it "should allow accessing the home page" do
        get '/'
        last_response.should be_ok
      end
    end

**RSpec 1.x Resources**

*   [RSpec 1.x Docs](http://rspec.info/)
*   [Source on github](https://github.com/dchelimsky/rspec)
*   [Resources for RSpec 1.x developers/contributors](https://github.com/dchelimsky/rspec-dev)


### Usage with Bacon

After installing [Bacon][bc], setting it up works similar to `Test::Unit`:

    ENV['RACK_ENV'] = 'test'
    require 'bacon'
    require 'rack/test'
    
    begin 
      require_relative 'my-app.rb'
    rescue NameError
      require File.expand_path('my-app.rb', __FILE__)
    end
 
    module TestMixin
      include Rack::Test::Methods
      Bacon::Context.send(:include, self)
      def app() Sinatra::Application end
    end

### Usage with MSpec

After installing [MSpec][ms], you set it up like this:

    ENV['RACK_ENV'] = 'test'
    require 'mspec'
    require 'rack/test'
    
    begin 
      require_relative 'my-app.rb'
    rescue NameError
      require File.expand_path('my-app.rb', __FILE__)
    end
 
    include Rack::Test::Methods
    def app() Sinatra::Application end

### Usage with Protest

After installing [Protest][pt], setting it up works similar to `Test::Unit`:

    ENV['RACK_ENV'] = 'test'
    require 'protest'
    require 'rack/test'
 
    begin 
      require_relative 'my-app.rb'
    rescue NameError
      require File.expand_path('my-app.rb', __FILE__)
    end
 
    module TestMixin
      include Rack::Test::Methods
      Protest::TestCase.send(:include, self)
      def app() Sinatra::Application end
    end

Using Capybara
--------------


### Steak

**spec/acceptance/acceptance_helper.rb**

    ENV['RACK_ENV'] = 'test'

    require 'rubygems'
    require 'steak'
    require 'rack/test'
    require 'capybara/dsl'

    RSpec.configure do |config|
      config.include Capybara
    end
 
    begin 
      require_relative '../../my-app.rb'
    rescue NameError
      require File.expand_path('../../my-app.rb', __FILE__)
    end

    Capybara.app = Sinatra::Application

**My Page Acceptance Spec**

    begin 
      require_relative 'acceptance_helper'
    rescue NameError
      require File.expand_path('acceptance_helper', __FILE__)
    end

    feature "My Page" do

      scenario "greets the visitor" do
        visit "/"
        page.should have_content "Welcome to my page!" 
      end

    end

**Steak Resources**

*   [Source on github](https://github.com/cavalle/steak)
*   [Documentation](http://rdoc.info/gems/steak/1.0.1/frames/)
*   [Timeless: BDD with RSpec and Steak](http://timeless.judofyr.net/bdd-with-rspec-and-steak)
*   [More Steak Resources](https://github.com/cavalle/steak/wiki/Resources)

Using Webrat 
------------

### Cucumber

**A Feature Example**

    Feature: View my page
      In order for visitors to feel welcome
      We must go out of our way
      With a kind greeting

      Scenario: My page
        Given I am viewing my page 
        Then I should see "Welcome to my page!"

**Step to it**

    Given /^I am viewing my page$/ do
      visit('/')
    end

    Then /^I should see "([^"]*)"$/ do |text|
       last_response.body.should match(/#{text}/m)
    end

**env.rb**

    ENV['RACK_ENV'] = 'test'

    require 'rubygems'
    require 'rack/test'
    require 'rspec/expectations'
    require 'webrat'

    begin 
      require_relative '../../my-app.rb'
    rescue NameError
      require File.expand_path('../../my-app.rb', __FILE__)
    end

    Webrat.configure do |config|
      config.mode = :rack
    end

    class WebratMixinExample
      include Rack::Test::Methods
      include Webrat::Methods
      include Webrat::Matchers

      Webrat::Methods.delegate_to_session :response_code, :response_body

      def app
        Sinatra::Application
      end
    end

    World{WebratMixinExample.new}

**Cucumber Resources**

*   [Cucumber Homepage](http://cukes.info/)
*   [Source on github](https://github.com/aslakhellesoy/cucumber)
*   [Documentation](https://github.com/aslakhellesoy/cucumber/wiki/)

[ct]: http://github.com/citrusbyte/contest#readme "Contest"
[rt]: http://github.com/brynary/rack-test/#readme "Rack::Test"
[tu]: http://ruby-doc.org/stdlib/libdoc/test/unit/rdoc/ "Test::Unit"
[ts]: http://test-spec.rubyforge.org/test-spec/ "Test::Spec"
[rs]: http://rspec.info/ "RSpec"
[bc]: http://github.com/chneukirchen/bacon#readme "Bacon"
[mt]: http://github.com/seattlerb/minitest#readme "Minitest"
[ms]: http://rubyspec.org/projects/show/mspec "MSpec"
[pt]: http://matflores.github.com/protest/ "Protest"
